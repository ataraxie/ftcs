\section{Introduction}
\label{sec:introduction}

 
The Internet as a platform of communication has developed a one-and-only character in the previous decade: no matter where devices and users are located, they connect to the Internet and talk to each other through it. Even in scenarios where these devices are close to each other on the same network, local architecture is rarely leveraged and all traffic has to go through the global network, possibly traversing multiple autonomous systems throughout the globe. Driven in particular by the growing domain of the Internet of things (IoT) where different ``smart" local devices require network communication, a movement towards making more use of local network infrastructure seems just as reasonable. Nonetheless, adding and configuring these devices in a local-area network may be error prone, time consuming, and non-inviting to the public that purchase them. On top of that, applications run by these devices may require unnecessary Internet connection in order to communicate with their peers. 


Imagine a classroom with students following a presentation which is concluded with a vote from studentsâ€™ smart phones. If students are connected to the same WiFi, ideally one student's phone could detect their peers phones in the network and open a local app that would manage the voting system. However, such voting systems are usually performed using online voting platforms where all voters have to connect to the Internet for accessing the platform. Despite the obvious unnecessary traffic, this scenario has another significant problem: the voting cannot be performed upon failing Internet access. This seems almost abstruse knowing that all participants are connected to the same local network.


In response to the aforementioned issues, zero-configuration networking an its suite of protocols (mDNS/DNS-SD)~\cite{rfc6762,rfc6763} intend to automatically discover devices and their services in a local area network, thus enabling new possibilities for device interaction in the application layer. As an example, the Mozilla Firefox\footnote{\url{https://wiki.mozilla.org/FlyWeb}} FlyWeb\footnote{\url{https://flyweb.github.io/spec/}} extension leverages this suite of protocols to allow clients of Web applications to start their own local Web server from within the browser. Advertised in the local network through mDNS, other devices in the network can detect the new server and can connect to it via their own browser. 


The FlyWeb extension caught our attention as it offers a range of new possibilities for Web applications and local vs. global network behavior. But, on its current implementation, it has severe limitations, one of them being the complete lack of fault tolerance: when the local server dies, the client-server network dies with it. Since this technology is inherently driven by the idea of any device being able to become a server, we assume that it is more likely that servers misbehave in comparison to the traditional scenario of ``real" Web servers. We therefore regard fault tolerance as very important in such networks and we think the lack of mechanisms for graceful recovery is problematic.


We propose an approach to enrich FlyWeb with fault tolerance. We hypothesize that a technology like FlyWeb is a good basis for fault tolerance through replication, since any participant can become the server. In the situation of a failing server, we think it is intuitive that a client can become the ``next" server and all other clients establish a connection to the new server. Obviously, replication comes at the cost of complexity. We intend to analyze the different strategies of replication and choose one that adheres best to our scenario. We aim to deliver our approach in a JavaScript library FTCS that provides fault tolerance to FlyWeb application developers without exposing the underlying technical details.