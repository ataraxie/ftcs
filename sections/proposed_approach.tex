\section{Proposed Approach}
\label{sec:approach}

Our goal is to build a framework to facilitate the development of offline client-server Web applications that robustly recover from server faults. 
We posit that the following features are prerequisites to achieving this:

\begin{enumerate}
    \item Nodes in the network trust each other;
    \item Any client, but exactly one client, has the ability to automatically assume the responsibilities of the server if the server goes down;
    \item All clients in the network have the capability to automatically update their connections to the new server in the event that the server migrates from one node to another;
    \item Communication in the network is not traffic intensive, i.e. nodes neither produce bursts of requests in a small period of time nor have payloads higher than some threshold $\tau$ that might generate bottlenecks in the network;
    
\end{enumerate}

The model we propose for achieving this is one in which clients connecting to the server automatically acquire distributed state including the following elements:

\begin{enumerate}
	\item Constant: A UUID for the initial host node (the first to serve the application);
    \item The current state of the server;
	\item A ``successorship'' list: a list of (potentially not all of the) nodes in the local network, in order of ``who is next'' to assume server responsibilities, in the event that the server goes down;
    \item Constant: The actual server code to execute, in the event that one of the clients needs to begin acting as the server.
\end{enumerate}

Note that the elements marked ``(Constant)'' are permanently fixed (for the lifetime of the application) when the initial server node first runs the application server.

We propose to develop a Javascript library that implements the functionality listed above, providing a clean interface to enable developers to seamlessly integrate fault-tolerance into their offline client-server Web applications, without having to worry about the details of how such fault-tolerance is achieved.

\subsection{API Overview}

Our current running name for the library is \texttt{\APIName}\footnote{We still need a proper acronym for it, e.g. \APIshort}, i.e. the next ship that will lead the flotilla after yet another sunk boat. We propose to implement the following interface in \APIName:


\begin{itemize}
	\item Server side:
    \begin{itemize}
    \begin{ttfamily}
      \item initServer(name)
      \item onReceive(msg, callback)
      \item commitState(callback)
    \end{ttfamily}
    \end{itemize}
    \item Client side:
    	\begin{itemize}
    	\begin{ttfamily}
    		\item initClient()
            \item connect(serverName)
            \item send(msg, payload)
    	\end{ttfamily}
    	\end{itemize}
\end{itemize}


We briefly discuss the major functions of our proposed API in the following subsections. Throughout the discussion, we use the TA queue example to illustrate our API usage.

{\bf Server initialization and service instantiation: } the first functions to initiate a server are {\ttfamily initServer} and {\ttfamily onReceive}. The former starts the local server in the device's browser and, after initialization, assigns a host name for that server. The later register entry points for services offered by that server.

In our queue system, one would initialize a server and define two functions to handle requests to enqueue students and also to dequeue them once they are helped. Additionally, the server provides the queue service in order to provide the current state of the queue. If no recognizable service is requested, the TAQueue server responds with the queue service.

\begin{lstlisting}[language=JavaScript]
    function getQueue(req, event) { ... }
    function handleEnqueue(req, event) { ... }
    function handleDequeue(req, event) { ... }

    (function main(){
        server = sship.initServer("TAQueue");
        server.onReceive('queue', getQueue, 
            default=true);
        server.onReceive('enqueue', handleEnqueue);
        server.onReceive('dequeue', handleDequeue);
    })();
\end{lstlisting}

{\bf Establishing connections: } as a server starts running, it broadcasts its name in the local-area network and clients in the same network can discover this server. A client device needs a single line of code to initialize itself. Upon initialization it will lookup for host servers in the network. Once a list of servers is retrieved and displayed, a client may select a server to connect to. In our TA queue example, we explicitly know the server name and skip the server list phase:

\begin{lstlisting}[language=JavaScript]
    (function main(){
        client = sship.initClient().connect("TAQueue");
    })();
\end{lstlisting}


{\bf Data exchange: } clients can ask for services through the {\ttfamily send} function. The function explicitly takes a requested service as one of its parameters and a payload as its second one. In our queue system, two distinct clients may request to enqueue themselves.

\begin{lstlisting}[language=JavaScript]
    (function main(){
        client1 = sship.initClient().connect("TAQueue");
        client1.send(enqueue, 
            {student: "Arthur", csid: "cs4321"});

        client2 = sship.initClient().connect("TAQueue");
        client2.send(enqueue, 
            {student: "Paul", csid: "cs9876"});
    })();
\end{lstlisting}

{\bf Updating the server state: } Finally, it is necessary to define which data structures or variables are important for a server, thus the {\ttfamily commitState} function receives a function which is executed every time that a service is successfully requested and executed in that server. Revisiting our {\ttfamily server = sship.initServer("TAQueue")} code snippet, we would add a final function to define how the server would be updated after queueing/dequeuing students.

\begin{lstlisting}[language=JavaScript]
    var queue = [];
    function currentQueue() { return queue; }

    (function main(){
        server = sship.initServer("TAQueue");
        ...
        server.commitState(currentQueue);
    })();
\end{lstlisting}


\subsection{What's happening under the hood?}

When a server is initialized and it starts running, we envision that our API will create a state for that server and that this state is updated after the execution of any received message callback. 

As clients connect to a server, the clients themselves assign their own host names and the server keeps a list of connected clients. Upon connection, the clients start a heart beat routine to monitor the server state. Clients are updated in two scenarios, the first one happens through one acknowledgement in the heart beat cycle while the other happens whenever a client receives an acknowledgement from a service usage. In both cases, the acknowledgement carries the server's current state and clients maintain a replica of that state within their storage memory.

Upon failed messages, the clients will start their own servers with the same name as the one that they were connecting to, but followed by a randomly generated unique suffix. As this new server is started and broadcasted in the network, clients will detect other servers with the original server prefix and thus, they will have to reach a consensus among themselves on who will be the next leading server. Through this process, they will also exchange their own server states such that they can eventually identify which client has the most up-to-date state.