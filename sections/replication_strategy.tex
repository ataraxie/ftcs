\subsection{Replication Strategy}

We aim to leverage the concepts of \textbf{eventual consistency} and \textbf{lazy replication} for our fault tolerance approach. 
We argue that our domain of local ad-hoc offline Web applications will mostly tolerate minor time frames of inconsistent states and we rather aim to increase availability and performance.

When a server is initialized and it starts running, we envision that our API will create a state for that server and that this state is updated after the execution of any received message callback. 
As clients connect to a server, the clients themselves assign their own host names and the server keeps a list of connected clients.
Changes to the server state are broadcasted to all clients. 
Obviously, this proposes a sensitive point for possible inconsistencies: what if the server dies before changes are broadcasted? 
What if the broadcast to our next server fails and the next server takes over with a stale state? 
Our current idea is to converge to a consistent state in accordance to the eventual consistency principle when clients (re-)connect to the new server: upon connecting, they can send their current state associated with a timestamp of the last modification and we can determine the most current version of the state with this strategy.
Clearly, this could easily be spoofed by malicious clients imposing a manipulated state onto our network, but as stated previously, we allow ourselves to assume full trust between all participants in the network for simplification. 
We have also considered using a CRDT for our implementation, but we think that while we might find a conflict-free replicated queue for our TA example application, we would not be able to generalize beyond this example.