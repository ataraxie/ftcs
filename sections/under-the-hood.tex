\subsection{What's happening under the hood?}

When a server is initialized and it starts running, we envision that our API will create a state for that server and that this state is updated after the execution of any received message callback. 

As clients connect to a server, the clients themselves assign their own host names and the server keeps a list of connected clients. Upon connection, the clients start a heart beat routine to monitor the server state. Clients are updated in two scenarios, the first one happens through one acknowledgement in the heart beat cycle while the other happens whenever a client receives an acknowledgement from a service usage. In both cases, the acknowledgement carries the server's current state and clients maintain a replica of that state within their storage memory.

Upon failed messages, one client will start its own cached server with the same name as the one that they were connecting to, but followed by a randomly generated unique suffix. As this new server is started and broadcasted in the network, clients will detect the new server based on the original server prefix and thus, they will have to reach a consensus among themselves on who has the most up to date state for the next leading server. Through this process, they exchange their own states such that they can eventually identify which client had the most up-to-date state previous to failure.
